
template<typename T> 
struct ErrorOr {
    err: i32;
    value: T;
}

template<typename T>
fn booger(a: T): T {
    return a;
}

struct Point {
    x: i8;
    y: i8;
}

enum AstNode {
    None,
    Func { id: i32 }
}

fn P(p: Point): Point {
    return p;
}

fn func(a: i32): i32 {
    let p: Point;
    P(p);
    return a;
}

fn main(): i32 {
    let a: i8 = booger<i8>(5);
    let c: i32 = booger<i16>(5);
    let b: i32 = sizeof (Point);

    let s: ErrorOr<i8>;

    if (a >= 8) {
        return 11;
    } else if (b == a) {
        return 8;
    } else {
        return 0;
    }

    for (let i = 0; i < 8; i = i + 1) {
        sizeof Point;
    }

    while (a == 0) {
        sizeof Point;
    }

    switch (a) {
        case 5:
            {}
        default:
            {}
    }

    let e: AstNode;

    switch (e) {
        case AstNode::None => (blurg: i32) {
            
        }
        case AstNode::Func => (blurg: i32) {

        }
    }

    if (e is AstNode::Func) => (e: AstNode::Func) {

    }



    return func(b) * 4;
}