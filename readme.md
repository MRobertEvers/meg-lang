# Sushi Lang

Sushi is my cat.

The last several branches were an exploration of how to appropriately generate llvm-ir. What I'm realizing is that it might be best to specify some language features a bit better so I can organize the code and data in a way that makes more sense.

Postfix expressions. Identifiers can have several postfix operations performed on them.

```
postfix_expr := simple_expr postfix_expr_tail

postfix_expr_tail := "[" expr "]"
                    | "(" func-args ")"
                    | "." ident
                    | "->" ident
                    | "++"
                    | "--"
```


# Building

This build is similar to a previous example. We use clang to call into the code generated by LLVM.

Build uses cmake. 

```
mkdir build
cd build
cmake ..
# Use this for debug
cmake .. -DCMAKE_BUILD_TYPE=Debug
```

Once cmake has generated the build make files.

```
make
```

The output is `sushi`.

Once you run `./sushi` it will generate the output file from the hardcoded program. 

```cpp
char const buf[] =
    "fn func(a: i32, b: i32): i8 { let x: i32 = 4; return a*8+x+b; } fn f72(): i8 { "
    "return 12*1*3+4; }";
```

The output is `output.o`. We can use clang to bootstrap calling into our object code with `test.cpp`.

```
clang++ test.cpp output.o -o test

./test

>>> Value: 4
>>> Value: 12
>>> Value: 13
>>> Value: 14
>>> Value: 15
>>> Value: 16
>>> Value: 20
>>> Value: 28
```

# Exploration 6


In this branch we use our `IAstVisitor` to implement the code generation. Currently, any required type checking (i.e. required by llvm) is done during codegen, which is not what we want in the long term.

I made a few realizations. First I realize now why the Kaleidoscope example has a `parse_primary` function.

C++ has a similar notion, https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170. Basically, we need to specially parse infix, and postfix expressions. So here I think I will device the term for Sushi Lang, __simple expression__. A simply expression is any expression that can be parsed from left to right without knowing where other expressions fall in the AST.

A __complex expression__ is one where it can't be simply parsed from left to right. I.e. Expressions that come later in the parse might affect the position of expressions earlier in the parse. Right now, this only results from infix expressions, i.e. Binary Operations.

```
simple_expr := 
    variable_expr | 
    literal_expr | 
    '(' complex_expr ')'

complex_expr :=
    simple_expr | 
    simple_expr unary_op complex_expr
```

So, in our parse code, we have functions to parse a complex expression, and a simple expression. 

For the most part, this is just exploring how to pass structures, pointers, etc and how to access fields on them.


# Notes

Additionally, I spent some time thinking about how to handle type names (as opposed to names of variables and functions).

I did a quick check on clang and it seems like they track type names and value names. They have a `TypeDecl` and a `ValueDecl` class that inherit from `NamedDecl`. I determined that they are stored in the same structure when exporing scope names.

E.g.

```cpp
struct Wow
{
	int x;
};

int
main()
{

	auto v = Wow;

	return 1;
}
```

The above code generates the following error
```
no.cpp:24:11: error: 'Wow' does not refer to a value
        auto v = Wow;
```


I looked at passing structs by value, but it appears that llvm doesn't have native support for that. I looked at how clang passes structs by value. Basically, it instead just passes an array of integers that is big enough to fit the struct and then performs some llvm type casting.

The following c code produces the llvm ir below. You can use clang to emit llvm ir, `clang -S -emit-llvm test_c.c`.

```c
struct my_struct
{
	int a;
	int b;
	int c;
};

int
func(struct my_struct s)
{
	return s.b;
}

int
call_func()
{
	struct my_struct s;
	s.a = 0;
	s.b = 3;
	s.c = 6;
	return func(s);
}
```

```llvm-ir
; ModuleID = 'test_c.c'
source_filename = "test_c.c"
target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
target triple = "arm64-apple-macosx12.0.0"

%struct.my_struct = type { i32, i32, i32 }

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @func([2 x i64] %0) #0 {
  %2 = alloca %struct.my_struct, align 4
  %3 = alloca [2 x i64], align 8
  store [2 x i64] %0, [2 x i64]* %3, align 8
  %4 = bitcast %struct.my_struct* %2 to i8*
  %5 = bitcast [2 x i64]* %3 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %4, i8* align 8 %5, i64 12, i1 false)
  %6 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %2, i32 0, i32 1
  %7 = load i32, i32* %6, align 4
  ret i32 %7
}

; Function Attrs: argmemonly nofree nosync nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #1

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @call_func() #0 {
  %1 = alloca %struct.my_struct, align 4
  %2 = alloca [2 x i64], align 8
  %3 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 0
  store i32 0, i32* %3, align 4
  %4 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 1
  store i32 3, i32* %4, align 4
  %5 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 2
  store i32 6, i32* %5, align 4
  %6 = bitcast [2 x i64]* %2 to i8*
  %7 = bitcast %struct.my_struct* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 8 %6, i8* align 4 %7, i64 12, i1 false)
  %8 = load [2 x i64], [2 x i64]* %2, align 8
  %9 = call i32 @func([2 x i64] %8)
  ret i32 %9
}

attributes #0 = { noinline nounwind optnone ssp uwtable "disable-tail-calls"="false" "frame-pointer"="non-leaf" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "probe-stack"="__chkstk_darwin" "stack-protector-buffer-size"="8" "target-cpu"="apple-m1" "target-features"="+aes,+crc,+crypto,+dotprod,+fp-armv8,+fp16fml,+fullfp16,+lse,+neon,+ras,+rcpc,+rdm,+sha2,+sha3,+sm4,+v8.5a,+zcm,+zcz" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5, !6}
!llvm.ident = !{!7}

!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 12, i32 0]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 1, !"branch-target-enforcement", i32 0}
!3 = !{i32 1, !"sign-return-address", i32 0}
!4 = !{i32 1, !"sign-return-address-all", i32 0}
!5 = !{i32 1, !"sign-return-address-with-bkey", i32 0}
!6 = !{i32 7, !"PIC Level", i32 2}
!7 = !{!"Apple clang version 13.0.0 (clang-1300.0.29.3)"}
```

## Notes - Calling with structs (pointers)

Passing structs by pointers is straight forward, llvm ir that clang produces looks like this;

```c
struct my_struct
{
	int a;
	int b;
	int c;
};

int
func(struct my_struct* s)
{
	return s->b;
}

int
call_func()
{
	struct my_struct s;
	s.a = 0;
	s.b = 3;
	s.c = 6;
	return func(&s);
}
```

```llvm-ir
; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @func(%struct.my_struct* %0) #0 {
  %2 = alloca %struct.my_struct*, align 8
  store %struct.my_struct* %0, %struct.my_struct** %2, align 8
  %3 = load %struct.my_struct*, %struct.my_struct** %2, align 8
  %4 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %3, i32 0, i32 1
  %5 = load i32, i32* %4, align 4
  ret i32 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @call_func() #0 {
  %1 = alloca %struct.my_struct, align 4
  %2 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 0
  store i32 0, i32* %2, align 4
  %3 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 1
  store i32 3, i32* %3, align 4
  %4 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 2
  store i32 6, i32* %4, align 4
  %5 = call i32 @func(%struct.my_struct* %1)
  ret i32 %5
}
```

The llvm ir that is produced by the current sushi lang program is

```
struct my_struct {
    a: i32;
    b: i32;
}

fn func(s: my_struct*): i32 {
    let x: i32 = s.a; 
    return s.b; 
}
```

```
%my_struct = type { i32, i32 }

define i32 @func(%my_struct* %s) {
entry:
  %s1 = alloca %my_struct*, align 8
  store %my_struct* %s, %my_struct** %s1, align 8
  %x = alloca i32, align 4
  %Deref = load %my_struct*, %my_struct** %s1, align 8
  %my_struct.a = getelementptr inbounds %my_struct, %my_struct* %Deref, i32 0, i32 0
  %0 = load i32, i32* %my_struct.a, align 4
  store i32 %0, i32* %x, align 4
  %Deref2 = load %my_struct*, %my_struct** %s1, align 8
  %my_struct.b = getelementptr inbounds %my_struct, %my_struct* %Deref2, i32 0, i32 1
  %1 = load i32, i32* %my_struct.b, align 4
  ret i32 %1
}
```

# Notes - Pass by Reference

Calling by reference is identical to call by pointer

```
struct my_struct
{
	int a;
	int b;
	int c;
};

int
func(struct my_struct& s)
{
	return s.b;
}

int
call_func()
{
	struct my_struct s;
	s.a = 0;
	s.b = 3;
	s.c = 6;
	return func(s);
}
```

```
; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @_Z4funcR9my_struct(%struct.my_struct* nonnull align 4 dereferenceable(12) %0) #0 {
  %2 = alloca %struct.my_struct*, align 8
  store %struct.my_struct* %0, %struct.my_struct** %2, align 8
  %3 = load %struct.my_struct*, %struct.my_struct** %2, align 8
  %4 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %3, i32 0, i32 1
  %5 = load i32, i32* %4, align 4
  ret i32 %5
}

; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @_Z9call_funcv() #0 {
  %1 = alloca %struct.my_struct, align 4
  %2 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 0
  store i32 0, i32* %2, align 4
  %3 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 1
  store i32 3, i32* %3, align 4
  %4 = getelementptr inbounds %struct.my_struct, %struct.my_struct* %1, i32 0, i32 2
  store i32 6, i32* %4, align 4
  %5 = call i32 @_Z4funcR9my_struct(%struct.my_struct* nonnull align 4 dereferenceable(12) %1)
  ret i32 %5
}
```

## Notes - GEP

GEP takes a PointerToTy as it's Ptr value.

I.e.

```
llvm::Type* PointerToTy = ...; // Must be a pointer type

```


## Notes - Deref on Struct Nested

```c
struct Nested
{
	int n;
};

struct T
{
	int a;
	struct Nested b;
};

int
my_func(struct T* my_t)
{
	int a = my_t->a;
	return my_t->b.n + a;
}
```

```
; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @my_func(%struct.T* %0) #0 {
  %2 = alloca %struct.T*, align 8
  %3 = alloca i32, align 4
  store %struct.T* %0, %struct.T** %2, align 8
  %4 = load %struct.T*, %struct.T** %2, align 8
  %5 = getelementptr inbounds %struct.T, %struct.T* %4, i32 0, i32 0
  %6 = load i32, i32* %5, align 4
  store i32 %6, i32* %3, align 4
  %7 = load %struct.T*, %struct.T** %2, align 8
  %8 = getelementptr inbounds %struct.T, %struct.T* %7, i32 0, i32 1
  %9 = getelementptr inbounds %struct.Nested, %struct.Nested* %8, i32 0, i32 0
  %10 = load i32, i32* %9, align 4
  %11 = load i32, i32* %3, align 4
  %12 = add nsw i32 %10, %11
  ret i32 %12
}
```