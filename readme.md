# Sushi Lang

Sushi is my cat.

In this branch we use our `IAstVisitor` to implement the code generation. Currently, any required type checking (i.e. required by llvm) is done during codegen, which is not what we want in the long term.

I made a few realizations. First I realize now why the Kaleidoscope example has a `parse_primary` function.

C++ has a similar notion, https://docs.microsoft.com/en-us/cpp/cpp/types-of-expressions?view=msvc-170. Basically, we need to specially parse infix, and postfix expressions. So here I think I will device the term for Sushi Lang, __simple expression__. A simply expression is any expression that can be parsed from left to right without knowing where other expressions fall in the AST.

A __complex expression__ is one where it can't be simply parsed from left to right. I.e. Expressions that come later in the parse might affect the position of expressions earlier in the parse. Right now, this only results from infix expressions, i.e. Binary Operations.

```
simple_expr := 
    variable_expr | 
    literal_expr | 
    '(' complex_expr ')'

complex_expr :=
    simple_expr | 
    simple_expr unary_op complex_expr
```

So, in our parse code, we have functions to parse a complex expression, and a simple expression. 

Additionally, I spent some time thinking about how to handle type names (as opposed to names of variables and functions).

I did a quick check on clang and it seems like they track type names and value names. They have a `TypeDecl` and a `ValueDecl` class that inherit from `NamedDecl`. I determined that they are stored in the same structure when exporing scope names.

E.g.

```cpp
struct Wow
{
	int x;
};

int
main()
{

	auto v = Wow;

	return 1;
}
```

The above code generates the following error
```
no.cpp:24:11: error: 'Wow' does not refer to a value
        auto v = Wow;
```


# Building

This build is similar to a previous example. We use clang to call into the code generated by LLVM.

Build uses cmake. 

```
mkdir build
cd build
cmake ..
```

Once cmake has generated the build make files.

```
make
```

The output is `sushi`.

Once you run `./sushi` it will generate the output file from the hardcoded program. 

```cpp
char const buf[] =
    "fn func(a: i32, b: i32): i8 { let x: i32 = 4; return a*8+x+b; } fn f72(): i8 { "
    "return 12*1*3+4; }";
```

The output is `output.o`. We can use clang to bootstrap calling into our object code with `test.cpp`.

```
clang++ test.cpp output.o -o test

./test

>>> Value: 4
>>> Value: 12
>>> Value: 13
>>> Value: 14
>>> Value: 15
>>> Value: 16
>>> Value: 20
>>> Value: 28
```